"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SeparatedFileHelper = void 0;
exports.handleIOError = handleIOError;
const tslib_1 = require("tslib");
const path_1 = tslib_1.__importDefault(require("path"));
const fs = tslib_1.__importStar(require("fs"));
const fsp = tslib_1.__importStar(require("fs/promises"));
const safe_encoder_1 = require("./safe-encoder");
function handleIOError(e) {
    if (e.code === 'ENOENT') {
        return;
    }
    else {
        console.error(e);
    }
}
class SeparatedFileHelper {
    opts;
    get lockFile() {
        return path_1.default.join(this.opts.filename, '.lock');
    }
    get _lastExpireFile() {
        return path_1.default.join(this.opts.filename, '.lastExpire');
    }
    constructor(opts) {
        this.opts = opts;
    }
    getLastExpire() {
        try {
            return Number(fs.readFileSync(this._lastExpireFile, 'utf8'));
        }
        catch (error) {
            handleIOError(error);
        }
        return 0;
    }
    setLastExpire(expire) {
        try {
            fsp.writeFile(this._lastExpireFile, expire.toString());
        }
        catch (error) {
            handleIOError(error);
        }
    }
    async get(key) {
        try {
            let rawData = await fsp.readFile(this._getKey(key));
            let data = this.opts.deserialize(rawData);
            return data;
        }
        catch (error) {
            handleIOError(error);
        }
    }
    /**
     * 根据键获取文件内容
     * @param key - 文件键名，同时也是文件名
     * @returns 返回一个Promise，解析为文件内容
     */
    getSync(key) {
        try {
            let rawData = fs.readFileSync(this._getKey(key));
            let data = this.opts.deserialize(rawData);
            return data;
        }
        catch (error) {
            handleIOError(error);
        }
    }
    _getKey(key) {
        return path_1.default.join(this.opts.filename, safe_encoder_1.SafeFilenameEncoder.encode(key));
    }
    async set(key, value) {
        try {
            let rawData = this.opts.serialize(value);
            await fsp.mkdir(this.opts.filename, {
                recursive: true,
            });
            await fsp.writeFile(this._getKey(key), rawData);
        }
        catch (e) {
            handleIOError(e);
        }
    }
    async delete(key) {
        try {
            await fsp.unlink(this._getKey(key));
            return true;
        }
        catch (e) {
            handleIOError(e);
            return false;
        }
    }
    async clear() {
        await fsp.rm(this.opts.filename, {
            recursive: true,
            force: true,
        });
    }
    async clearExpire(clearExpire) {
        try {
            let keys = await fsp.readdir(this.opts.filename);
            for (const key of keys) {
                clearExpire(key);
            }
            await fsp.writeFile(this._lastExpireFile, Date.now().toString());
        }
        catch (error) {
            handleIOError(error);
        }
    }
    async entries() {
        return fsp.readdir(this.opts.filename).then((keys) => {
            return Promise.all(keys.map(async (key) => {
                key = safe_encoder_1.SafeFilenameEncoder.decode(key);
                return [key, await this.get(key)];
            }));
        });
    }
}
exports.SeparatedFileHelper = SeparatedFileHelper;
